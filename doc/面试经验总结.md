# 面试经验总结

## 1. gRPC和http有什么区别和联系

gRPC是google开源的一个RPC框架，基于HTTP2.0协议，底层使用了Netty加持。  
在接口不多，系统与系统交互较少的情况下，解决信息孤岛初期常用的一种手段。开发起来比较直接、方便，直接使用现成的HTTP协议进行传输。

对于大型企业，内部子系统、接口都非常多的情况下，RPC框架的优势就展现出来了，首先就是一个长连接的优势，不必每次通信都需要像HTTP进行三次握手建立连接、然后再进行四次挥手释放连接。

gRPC由服务端和客户端组成，服务端提供了一些可供客户端调用的函数接口，或者将其称之为“服务”，这些接口服务是定义在protobuffer文件中的，根据服务端、或者客户端的实现语言进行统一生成。

protobuf进行消息序列化，压缩率高，性能好，还有一个优势是跨语言。

## 2. 存储过程和SQL语句的区别

存储过程是一组完成特定功能的SQL合集，经过编译之后存储在数据库系统中，用户可通过传递参数进行调用其中的逻辑。在运行存储过程之前，数据库已经对其进行语法分析，并优化执行方案。这种已经编译好的SQL存储过程能够极大的提升SQL语句的性能，执行速度非常快。

存储过程优点：

1. 具备更好的性能；
2. 功能灵活，能够使用内置的函数完成复杂的判断和较为复杂的数据运算；
3. 减少网络传输；复杂的业务需要多条SQL语句，客户端和服务端之间传输的数据就非常大，存储过程能明显的解决大量网络传输问题，降低网络负载。
4. 具备更好的安全性能，数据库管理人员能够更加方便进行权限控制。并且还能够有助于避免SQL注入攻击。

存储过程缺点：

1. 架构不清晰，增加了业务和存储的耦合。
2. 开发维护成本比较高。存储过程将业务降维到了数据库，如果出现异常很难排查出问题所在。
3. 可移植性较差。

## 3. 统计500G 文件中每个单词的数量

回答1: 假设用HashTable的方式进行计数，一个单词的长度假设为30B, 自然界总共大概3w个单词，那么hashTable key值占用空间大小为
30 * 3 * 10^4 ~= 9*10^5 B ～= 900KB，因此所有的单词是能够存储到内存中的。关于value, 假设500G存储的是一个一模一样的单词，90 *
10 ^ 11 B, 数量最大值是 3*10^11

既然500G文件不能一次读取到内存中，那就对文件进行分割，例如可以按行进行分割，

## 4. 内存1G, 有一个500G文件里面全是int32数据，统计出现超过2次的int数据

思路：使用位图。int占32位，因此一个int可以表示32个整数，总共有2^32个整数，因此需要 2^32 / 32 = 2^27个int,
即：512M内存就能够存完全部的int32数据，我们开辟一个数组：int tmp[2^27], 从文件中读取一个数据a, tmp[a / 32]
即为其所存储的位置，int中偏移量为 a % 32，最终转换成对应的tmp[a / 32]中的转化成十进制数据是：n = 2^(a % 32)，操作逻辑见下面伪代码：

```
resultSet = []
forEach number in ReadedFile:
    int index = number / 32;
    int n = 2 ^ (number % 32);
    if (n & tmp[a / 32] == 0){
        // 说明存在这个数
        resultSet.push(number);
    }else{
        tmp[a / 32] |= n;
    }
end forEach;
```

## 5. MySQL 左连接、又连接和全连接有什么区别

左连接：返回包括左表中所有记录和右表中连接字段相等的记录.  
右连接：返回包括右表中的所有记录和左表中连接字段相等的记录。  
全连接：返回左右表中的全部记录和 连接字段相等的记录。  
内连接：只返回两个表中连接字段相等的记录。

## 6. MySQL一些面试题整理

1. **脏读**：事务A查询数据时，读取到了事务B并没有提交的事务。(读取到未提交的内容)

| 时间点 | 事务A        | 事务B    |
|---|------------|--------|
|1| 开启事务       |        |
|2|            | 开启事务   |
|3| 查询数据100条   |        |
|4|            | 插入一条数据 |
|5| 再查询数据为101条 |        |
|6|            | 提交事务       |

2. 读已提交内容,这是大多数数据库系统的默认隔离级别, 但是不是MySQL的默认隔离级别.

| 时间点 | 事务A        | 事务B    |
|---|------------|--------|
|1| 开启事务       |        |
|2|            | 开启事务   |
|3| 查询数据100条   |        |
|4|            | 插入一条数据 |
|5| 再查询数据为100条 |        |
|6|            | 提交事务   |
|7| 查询数据为101条  |        |

3. 可重复读, MySQL默认的事务隔离级别.

| 时间点 | 事务A           | 事务B      |
|---|---------------|----------|
|1| 开启事务          ||
|2|               | 开启事务     |
|3| 查询"张三"不存在     ||
|4|               | 插入数据"张三" |
|5|               | 提交事务     |
|6| 查询数据"张三"仍然不存在 |          |
|7| 插入数据"张三"失败    ||

这种情况就就属于**幻读**, 查询不存在, 插入又插入失败, "张三"这个数据就像幻觉一样出现这在.

4. 串行化, 这是最高的隔离级别, 通过强制进行事务排序, 使之不能相互冲突, 从而解决幻读问题, 这种解决方式会进行加"共享锁",
   导致大量的超时现象和锁竞争, 因此这种隔离级别很少使用.

## 6. Java一些面试题整理

### 6.1 可重入锁(ReentrantLock)

简介: 当一个线程持有这个锁时, 当这个线程并没有释放, 再次请求这个锁仍然能够成功. 案例如下:

```java
public synchronized void A(){
    B();
}

public synchronized void B(){
    System.out.println("B");
}
```

方法A调用方法B, 如果不是可重入锁, 那么调用就会失败.